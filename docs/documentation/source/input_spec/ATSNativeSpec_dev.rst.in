ATS Native XML Input Specification V1
#######################################

.. contents:: **Table of Contents**

  
Syntax of the Specification
#######################################

* Input specification for each ParameterList entry consists of two parts.  
  First, a bulleted list defines the usage syntax and available options.  
  This is followed by example snipets of XML code to demonstrate usage.

* In many cases, the input specifies data for a particular parameterized model, and ATS 
  supports a number of parameterizations.  
  For example, initial data might be uniform (the value is required), or linear in y (the value 
  and its gradient are required).  
  Where ATS supports a number of parameterized models for quantity Z, the available 
  models will be listed by name, and then will be described in the subsequent section.  
  For example, the specification for an `"X`" list might begin with the following:

  * `"Y`" ``[string]`` **"default_value"**, `"other`", `"valid`", `"options`"

  * Z ``[Z-spec]`` Model for Z, choose exactly one of the following: (1) `"z1`", or (2) `"z2`" (see below) 

Here, an `"X`" is defined by a `"Y`" and a `"Z`".  
The `"Y`" is a string parameter but the `"Z`" is given by a model (which will require its own set of parameters).
The options for `"Z`" will then be described as a spec:

 * `"z1`" applies model z1.  Requires `"z1a`" ``[string]``

 * `"z2`" applies model z2.  Requires `"z2a`" ``[double]`` and `"z2b`" ``[int]``

An example of using such a specification:

.. code-block:: xml

    <ParameterList name="X">
      <Parameter name="Y" type="string" value="hello"/>
      <ParameterList name="z2">
        <Parameter name="z2a" type="double" value="0.7"/>
        <Parameter name="z2b" type="int" value="3"/>
      </ParameterList>   
    </ParameterList>   
 
Here, the user is defining X with Y="hello", and Z will be a z2 constructed with z2a=0.7 and z2b=3.

Conventions:

* Reserved keywords and labels are `"quoted and italicized`" -- these
  labels or values of parameters in user-generated input files must
  match (using XML matching rules) the specified or allowable values.

* User-defined labels are indicated with ALL-CAPS, and are meant to
  represent a typical name given by a user - these can be names or
  numbers or whatever serves best the organization of the user input
  data.

* Bold values are default values, and are used if the Parameter
  is not provided.


Symbol Index
############

.. include:: symbol_table.rst
  
Main
####
{ simulation_driver }
  

Mesh
####
{ ats_mesh_factory }


Region
######
{ Region }

All
===
{ RegionAll }

Box
===
{ RegionBox }

Plane
=====
{ RegionPlane }

Labeled Set
===========
{ RegionLabeledSet }

Function Color
==============
{ RegionFunctionColor }

Point
=====
{ RegionPoint }

Logical
=======
{ RegionLogical }

Polygon
=======
{ RegionPolygon}

Enumerated
==========
{ RegionEnumerated }

Boundary
========
{ RegionBoundary }

Box Volume Fraction
===================
{ RegionBoxVolumeFractions }

Line Segment
============
{ RegionLineSegment }


Coordinator
############
{ coordinator }
   

Visualization
##############
{ Visualization }


Checkpoint
##############
{ Checkpoint }  


 
Observation
##############
{ Observable }


PK
###
{ PK }

Base PKs
========
There are several types of PKs, and each PK has its own valid input
spec.  However, there are three main types of PKs, from which nearly
all PKs derive.  Note that none of these are true PKs and cannot stand
alone.

PK: Physical
------------
{ pk_physical_default }


PK: BDF
-------
{ pk_bdf_default }

PK: Physical and BDF
--------------------
{ pk_physical_bdf_default }

Physical PKs
============
Physical PKs are the physical capability implemented within ATS.

Flow PKs
--------
Flow PKs include the flow of water both above and below-ground.

Richards PK
^^^^^^^^^^^
{ richards }

Permafrost Flow PK
^^^^^^^^^^^^^^^^^^
{ permafrost }

Overland Flow, pressure primary variable, PK
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
{ overland_pressure }

Overland Flow with Ice
^^^^^^^^^^^^^^^^^^^^^^
{ icy_overland }

Snow Distribution PK
^^^^^^^^^^^^^^^^^^^^
{ snow_distribution }


Energy PKs
-----------
Advection and diffusion of energy, including phase change.

Energy Base PK
^^^^^^^^^^^^^^
{ energy_base }

Two-Phase subsurface Energy PK
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
{ energy_two_phase }

Three-Phase subsurface Energy PK
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
{ energy_three_phase }

Overland energy with Ice
^^^^^^^^^^^^^^^^^^^^^^^^
{ energy_surface_ice }



Surface Energy Balance PKs
------------------------------


Surface Energy Balance / Snow -- Monolithic Version
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



Surface Energy Balance -- Generic Version
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



Biogeochemistry
-----------------


Biogeochemistry -- Monolithic Version
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



Deformation
-------------


Volumetric Deformation
^^^^^^^^^^^^^^^^^^^^^^



MPCs
===============

MPCs couple other PKs, and are the non-leaf nodes in the PK tree.

WeakMPC
----------

StrongMPC
----------

Physical MPCs
===============
 coupling is an art, and requires special off-diagonal work.  Physical MPCs can derive from default MPCs to provide special work.

Coupled Water MPC
--------------------

{ mpc_coupled_water }
{ mpc_delegate_water }


Subsurface MPC
--------------------

Permafrost MPC
--------------------

State
##############

State consists of two sublists, one for evaluators and the other for
atomic constants.  The latter is currently called `"initial
conditions`", which is a terrible name which must be fixed.

example:

.. code-block:: xml
                
  <ParameterList name="state">
    <ParameterList name="field evaluators">
      ...
    </ParameterList>
    <ParameterList name="initial conditions">
      ...
    </ParameterList>
  </ParameterList>

 

Field Evaluators
=================


PrimaryVariableEvaluator
------------------------
{ primary_variable_field_evaluator }


IndependentVariableEvaluator
----------------------------

Independent variables are provided either by a function or directly loaded from a file.

From Function
^^^^^^^^^^^^^
{ independent_variable_field_evaluator_fromfunction }

From File
^^^^^^^^^
{ independent_variable_field_evaluator_fromfile }


Water Content
-------------

Water content is the conserved quantity in most flow equations, including
Richard's equation with and without ice.  A variety of evaluators are provided
for inclusion of multiple phases.

Richards Equation water content
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
{ richards_water_content_evaluator }

Liquid+Gas water content
^^^^^^^^^^^^^^^^^^^^^^^^
{ liquid_gas_water_content_evaluator }

Liquid+Ice water content
^^^^^^^^^^^^^^^^^^^^^^^^
{ liquid_ice_water_content_evaluator }

Liquid+Ice+Gas water content
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
{ three_phase_water_content_evaluator }


Surface Water potential surfaces
--------------------------------

Evaluators for 

SurfaceElevation
^^^^^^^^^^^^^^^^^^
{ meshed_elevation_evaluator }

SurfacePotential
^^^^^^^^^^^^^^^^^^^
{ pres_elev_evaluator }

SnowSurfacePotential
^^^^^^^^^^^^^^^^^^^^^^
{ snow_skin_potential_evaluator }

Surface water content
^^^^^^^^^^^^^^^^^^^^^
{ overland_pressure_water_content_evaluator }


..
    KEEP GOING!

    
Generic Evaluators
---------------------------------

Several generic evaluators are provided.

Additive
^^^^^^^^
{ AdditiveEvaluator }

Multiplicative
^^^^^^^^^^^^^^
{ MultiplicativeEvaluator }

Column summation
^^^^^^^^^^^^^^^^
{ ColumnSumEvaluator }

Subgrid disaggregation
^^^^^^^^^^^^^^^^^^^^^^
{ SubgridDisaggregateEvaluator }



InitialConditions
=================

Initial condition specs are used in two places:

* within the PK_ spec which describes the initial condition of primary variables (true
  initial conditions), and

* in the `"initial conditions`" sublist of state, in which the value
  of atomic constants are provided (not really initial conditions and
  should be renamed).  These atomic values are not controlled by
  evaluators, and are not included in the DaG.  Likely these should be
  removed entirely.
  
Initialization of constant scalars
------------------------------------

A constant scalar field is the global (with respect to the mesh)
constant.  At the moment, the set of such fields includes atmospheric
pressure.  The initialization requires to provide a named sublist with
a single parameter `"value`".

.. code-block:: xml

  <ParameterList name="fluid_density">
    <Parameter name="value" type="double" value="998.0"/>
  </ParameterList>


Initialization of constant vectors
------------------------------------

A constant vector field is the global (with respect to the mesh)
vector constant.  At the moment, the set of such vector constants
includes gravity.  The initialization requires to provide a named
sublist with a single parameter `"Array(double)`". In two dimensions,
is looks like

.. code-block:: xml

  <ParameterList name="gravity">
    <Parameter name="value" type="Array(double)" value="{{0.0, -9.81}}"/>
  </ParameterList>


Initialization of scalar fields
------------------------------------

A variable scalar field is defined by a few functions (labeled for instance,
`"Mesh Block i`" with non-overlapping ranges. 
The required parameters for each function are `"region`", `"component`",
and the function itself.

.. code-block:: xml

  <ParameterList name="porosity"> 
    <ParameterList name="function">
      <ParameterList name="Mesh Block 1">
        <Parameter name="region" type="string" value="Computational domain"/>
        <Parameter name="component" type="string" value="cell"/>
        <ParameterList name="function">
          <ParameterList name="function-constant">
            <Parameter name="value" type="double" value="0.2"/>
          </ParameterList>
        </ParameterList>
      </ParameterList>
      <ParameterList name="Mesh Block 2">
        ...
      </ParameterList>
    </ParameterList>
  </ParameterList>


Initialization of tensor fields
------------------------------------
 
A variable tensor (or vector) field is defined similarly to a variable
scalar field.  The difference lies in the definition of the function
which is now a multi-values function.  The required parameters are
`"Number of DoFs`" and `"Function type`".

.. code-block:: xml

  <ParameterList name="function">
    <Parameter name="Number of DoFs" type="int" value="2"/>
    <Parameter name="Function type" type="string" value="composite function"/>
    <ParameterList name="DoF 1 Function">
      <ParameterList name="function-constant">
        <Parameter name="value" type="double" value="1.9976e-12"/>
      </ParameterList>
    </ParameterList>
    <ParameterList name="DoF 2 Function">
      <ParameterList name="function-constant">
        <Parameter name="value" type="double" value="1.9976e-13"/>
      </ParameterList>
    </ParameterList>
  </ParameterList>


Initialization from a file
------------------------------------

Some data can be initialized from files. Additional sublist has to be
added to named sublist of the `"state`" list with the file name and
the name of attribute.  For a serial run, the file extension must be
`".exo`".  For a parallel run, it must be `".par`".  Here is an
example:

.. code-block:: xml

  <ParameterList name="permeability">
    <ParameterList name="exodus file initialization">
      <Parameter name="file" type="string" value="mesh_with_data.exo"/>
      <Parameter name="attribute" type="string" value="perm"/>
    </ParameterList>
  </ParameterList>



example:

.. code-block:: xml

  <ParameterList name="state">
    <ParameterList name="initial conditions">
      <ParameterList name="fluid_density">
        <Parameter name="value" type="double" value="998.0"/>
      </ParameterList>

      <ParameterList name="fluid_viscosity">
        <Parameter name="value" type="double" value="0.001"/>
      </ParameterList>

      <ParameterList name="gravity">
        <Parameter name="value" type="Array(double)" value="{{0.0, -9.81}}"/>
      </ParameterList>

    </ParameterList>
  </ParameterList>



BoundaryConditions
===================

{ bc_factory }

Flow-specific Boundary Conditions
----------------------------------

{ flow_bc_factory }






Time integrators, solvers, and other mathematical specs
#######################################################

Common specs for all solvers and time integrators, used in PKs.


TimeIntegrator
==============

{ TimestepControllerFactory }

TimestepControllerFixed
-----------------------
{ TimestepControllerFixed }


TimestepControllerStandard
--------------------------
{ TimestepControllerStandard }

TimestepControllerSmarter
-------------------------
{ TimestepControllerSmarter }

TimestepControllerFromFile
--------------------------
{ TimestepControllerFromFile }





Linear Solver
=============

Linear solver are almost exclusively iterative methods with a separate provided preconditioner.

Linear Solver: PCG
--------------------
{ LinearOperatorPCG }

Linear Solver: GMRES
--------------------
{ LinearOperatorGMRES }

Linear Solver: NKA
--------------------
{ LinearOperatorNKA }

Linear Solver: Amesos
---------------------
{ LinearOperatorAmesos }

Linear Solver: Belos GMRES
--------------------------
{ LinearOperatorBelosGMRES }


Preconditioner
===================

These can be used by a process kernel lists to define a preconditioner.  The only common parameter required by all lists is the type:

 * `"preconditioner type`" ``[string]`` **"identity"**, `"boomer amg`", `"trilinos ml`", `"block ilu`" ???
 * `"PC TYPE parameters`" ``[list]`` includes a list of parameters specific to the type of PC.

Example:

.. code-block:: xml

     <ParameterList name="my preconditioner">
       <Parameter name="type" type="string" value="trilinos ml"/>
        <ParameterList name="trilinos ml parameters"> ?????? check me!
            ... 
        </ParameterList>
     </ParameterList>


Hypre's Boomer AMG
-------------------
{ PreconditionerBoomerAMG }

Trilinos ML
-------------------
{ PreconditionerML }

Block ILU
-------------------
{ PreconditionerBlockILU }

Indentity
-------------------
The default, no PC applied.



NonlinearSolver
===================




Other Common Specs
##########################################

IOEvent
===================

{ IOEvent }

VerboseObject
===================

{ VerboseObject }
   

Function
===================

{ Function }

It is straightforward to add new functions as needed.

Constant Function
-------------------------
{ FunctionConstant }  

Tabular Function
-------------------------
{ FunctionTabular }

Smooth step Function
-------------------------
{ FunctionSmoothStep }

Polynomial Function
-------------------------
{ FunctionPolynomial }  

Multi-variable linear Function
------------------------------
{ FunctionLinear }  

Separable Function
------------------
{ FunctionSeparable }

Additive Function
------------------
{ FunctionAdditive }

Multiplicative Function
--------------------------
{ FunctionMultiplicative }

Composition Function
--------------------------
{ FunctionComposition }

Piecewise Bilinear Function
---------------------------
{ FunctionBilinear }

Distance Function
-----------------
{ FunctionDistance }

Monomial Function
-----------------
{ FunctionMonomial }

Standard Math Function
----------------------
{ FunctionStandardMath }



Operator
========

{ Operator }

OperatorAccumulation
-------------------------
{ PDE_Accumulation }

OperatorDiffusion
-----------------
{ PDE_DiffusionFactory }

{ PDE_Diffusion }

{ PDE_DiffusionMFD }

{ PDE_DiffusionMFDwithGravity }

{ PDE_DiffusionFV }

{ PDE_DiffusionFVwithGravity }


OperatorAdvection
-------------------------

{ PDE_Advection }

{ PDE_AdvectionUpwind }



